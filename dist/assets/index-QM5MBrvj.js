var Xt=Object.defineProperty;var qt=(e,t,s)=>t in e?Xt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s;var b=(e,t,s)=>qt(e,typeof t!="symbol"?t+"":t,s);import{Q as S,M as U}from"./index-C45-iC1Q.js";function _t(){return{4:{F:"#44ee00",D:"#f4f400",L:"#ff0000",R:"#2266ff"},6:{U:"#ffffff",F:"#44ee00",R:"#ff0000",D:"#f4f400",B:"#2266ff",L:"#ff8000"},8:{U:"#ffffff",F:"#44ee00",R:"#ff0000",D:"#f4f400",BB:"#2266ff",L:"#8800dd",BL:"#ff8000",BR:"#888888"},12:{U:"#ffffff",F:"#008800",R:"#ff0000",C:"#e8d0a0",A:"#3399ff",L:"#8800dd",E:"#ff66cc",BF:"#99ff00",BR:"#0000ff",BL:"#f4f400",I:"#ff8000",D:"#888888"},20:{R:"#f4f400",C:"#d41f69",F:"#008800",E:"#5c5c5c",L:"#8800dd",U:"#ffffff",A:"#007a89",G:"#ff0000",I:"#7d3b11",S:"#b9a1ff",H:"#3399ff",J:"#5ec4b6",B:"#44ee00",K:"#e8d0a0",D:"#aaaaaa",M:"#ff66cc",O:"#292929",P:"#ff8000",N:"#980000",Q:"#0000ff"}}}var pt=class{constructor(e,t){b(this,"prefixFree",!0);b(this,"gripnames",[]);this.facenames=e,t&&(this.gripnames=t);for(let s=0;this.prefixFree&&s<e.length;s++)for(let i=0;this.prefixFree&&i<e.length;i++)s!==i&&e[s].startsWith(e[i])&&(this.prefixFree=!1)}setGripNames(e){this.gripnames=e}splitByFaceNames(e){const t=[];let s=0;for(;s<e.length;){s>0&&s<e.length&&e[s]==="_"&&s++;let i=-1;for(let n=0;n<this.facenames.length;n++)e.substr(s).startsWith(this.facenames[n])&&(i<0||this.facenames[n].length>this.facenames[i].length)&&(i=n);if(i>=0)t.push(i),s+=this.facenames[i].length;else throw new Error(`Could not split ${e} into face names.`)}return t}joinByFaceIndices(e){let t="";const s=[];for(let i=0;i<e.length;i++)s.push(t),s.push(this.facenames[e[i]]),this.prefixFree||(t="_");return s.join("")}spinmatch(e,t){if(e===t)return!0;try{const s=this.splitByFaceNames(e),i=this.splitByFaceNames(t);if(s.length!==i.length&&s.length<3)return!1;for(let n=0;n<s.length;n++){for(let r=0;r<n;r++)if(s[n]===s[r])return!1;let o=!1;for(let r=0;r<i.length;r++)if(s[n]===i[r]){o=!0;break}if(!o)return!1}return!0}catch{return!1}}spinmatchv(e,t){return e.endsWith("v")&&t.endsWith("v")?this.spinmatch(e.slice(0,e.length-1),t.slice(0,t.length-1)):this.spinmatch(e,t)}unswizzle(e){(e.endsWith("v")||e.endsWith("w"))&&e[0]<="Z"&&(e=e.slice(0,e.length-1));const t=e.toUpperCase();for(let s=0;s<this.gripnames.length;s++){const i=this.gripnames[s];if(this.spinmatch(t,i))return i}return e}},It=class{notationToInternal(e){return e}notationToExternal(e){return e}},te=class{constructor(e,t){this.child=e,this.sw=t}notationToInternal(e){return e.family==="T"&&e.innerLayer===void 0&&e.outerLayer===void 0?new U(new S("FLRv",e.innerLayer,e.outerLayer),e.amount):this.child.notationToInternal(e)}notationToExternal(e){let t=e.family;return t.length>0&&t[t.length-1]==="v"&&(t=t.substring(0,t.length-1)),this.sw.spinmatch(t,"FLUR")?new U(new S("T",e.innerLayer,e.outerLayer),e.amount):this.child.notationToExternal(e)}},Dt=class{constructor(e,t){this.internalNames=e,this.externalNames=t}convertString(e,t,s){let i="";(e.endsWith("v")||e.endsWith("v"))&&e<="_"&&(i=e.slice(e.length-1),e=e.slice(0,e.length-1));const n=e.toUpperCase();let o=!1;return e!==n&&(o=!0,e=n),e=s.joinByFaceIndices(t.splitByFaceNames(e)),o&&(e=e.toLowerCase()),e+i}convert(e,t,s){const i=e.family,n=this.convertString(i,t,s);return i===n?e:new U(new S(n,e.innerLayer,e.outerLayer),e.amount)}notationToInternal(e){return this.convert(e,this.externalNames,this.internalNames)}notationToExternal(e){return this.convert(e,this.internalNames,this.externalNames)}},ee=class{constructor(e){this.child=e}notationToInternal(e){if(e.innerLayer===void 0&&e.outerLayer===void 0){if(Math.abs(e.amount)===1){if(e.family==="R++")return new U(new S("L",3,2),-2*e.amount);if(e.family==="R--")return new U(new S("L",3,2),2*e.amount);if(e.family==="D++")return new U(new S("U",3,2),-2*e.amount);if(e.family==="D--")return new U(new S("U",3,2),2*e.amount);if(e.family==="R_PLUSPLUS_")return new U(new S("L",3,2),-2*e.amount);if(e.family==="D_PLUSPLUS_")return new U(new S("U",3,2),-2*e.amount)}if(e.family==="y")return new U("Uv",e.amount);if(e.family==="x"&&Math.abs(e.amount)===2)return new U("ERv",e.amount/2)}return this.child.notationToInternal(e)}notationToExternal(e){return e.family==="ERv"&&Math.abs(e.amount)===1?new U(new S("x",e.innerLayer,e.outerLayer),e.amount*2):e.family==="ILv"&&Math.abs(e.amount)===1?new U(new S("x",e.innerLayer,e.outerLayer),-e.amount*2):e.family==="Uv"?new U(new S("y",e.innerLayer,e.outerLayer),e.amount):e.family==="Dv"?new U("y",-e.amount):this.child.notationToExternal(e)}},se=class{constructor(e){this.slices=e}notationToInternal(e){const t=e.family;return e.innerLayer||e.outerLayer||(t==="x"?e=new U("Rv",e.amount):t==="y"?e=new U("Uv",e.amount):t==="z"&&(e=new U("Fv",e.amount)),(this.slices&1)===1&&(t==="E"?e=new U(new S("D",(this.slices+1)/2),e.amount):t==="M"?e=new U(new S("L",(this.slices+1)/2),e.amount):t==="S"&&(e=new U(new S("F",(this.slices+1)/2),e.amount))),this.slices>2&&(t==="e"?e=new U(new S("D",this.slices-1,2),e.amount):t==="m"?e=new U(new S("L",this.slices-1,2),e.amount):t==="s"&&(e=new U(new S("F",this.slices-1,2),e.amount)))),e}notationToExternal(e){const t=e.family;if(!(e.innerLayer||e.outerLayer)){if(t==="Rv")return new U("x",e.amount);if(t==="Uv")return new U("y",e.amount);if(t==="Fv")return new U("z",e.amount);if(t==="Lv")return new U("x",-e.amount);if(t==="Dv")return new U("y",-e.amount);if(t==="Bv")return new U("z",-e.amount)}return e}},ie={U:"frl",L:"fld",R:"fdr",B:"dlr",u:"FRL",l:"FLD",r:"FDR",b:"DLR",Uv:"FRLv",Lv:"FLDv",Rv:"FDRv",Bv:"DLRv",D:"D",F:"F",BL:"L",BR:"R"},ne={U:"FRL",L:"FLD",R:"FDR",B:"DLR",u:"frl",l:"fld",r:"fdr",b:"dlr",Uv:"FRLv",Lv:"FLDv",Rv:"FDRv",Bv:"DLRv",D:"D",F:"F",BL:"L",BR:"R",d:"d",f:"f",bl:"l",br:"r"},zt={U:"FRL",L:"FLD",R:"FDR",B:"DLR"},kt=new S("y"),Et=new S("Dv"),Tt=class{constructor(e){b(this,"wcaHack",!1);b(this,"map",ie);this.child=e}notationToInternal(e){if(this.wcaHack&&e.innerLayer===2&&e.outerLayer===null){const s=zt[e.family];if(s)return new U(new S(s,e.innerLayer,e.outerLayer),e.amount)}const t=this.map[e.family];return t?new U(new S(t,e.innerLayer,e.outerLayer),e.amount):kt.isIdentical(e.quantum)?new U(Et,-e.amount):null}notationToExternal(e){if(this.wcaHack&&e.innerLayer===2&&e.outerLayer===null){for(const[t,s]of Object.entries(zt))if(this.child.spinmatch(e.family,s))return new U(new S(t,e.innerLayer,e.outerLayer),e.amount)}for(const[t,s]of Object.entries(this.map))if(this.child.spinmatch(e.family,s))return new U(new S(t,e.innerLayer,e.outerLayer),e.amount);return Et.isIdentical(e.quantum)?new U(kt,-e.amount):null}},oe=class extends Tt{constructor(t){super(t);b(this,"wcaHack",!0);this.map=ne}},Ut={U:"UBL",UL:"ULF",F:"UFR",UR:"URB",B:"DBL",D:"DFR",L:"DLF",R:"DRB",Uv:"UBLv",ULv:"ULFv",Fv:"UFRv",URv:"URBv",Bv:"DBLv",Dv:"DFRv",Lv:"DLFv",Rv:"DRBv"},dt=new S("x"),jt=new S("Rv"),re=new S("Lv"),gt=new S("y"),Ct=new S("Uv"),ae=new S("Dv"),bt=new S("z"),Pt=new S("Fv"),le=new S("Bv"),he=class{constructor(e){this.child=e}notationToInternal(e){if(e.innerLayer||e.outerLayer)return null;const t=Ut[e.family];return t?new U(new S(t,e.outerLayer,e.innerLayer),e.amount):dt.isIdentical(e.quantum)?new U(jt,e.amount):gt.isIdentical(e.quantum)?new U(Ct,e.amount):bt.isIdentical(e.quantum)?new U(Pt,e.amount):null}notationToExternal(e){for(const[t,s]of Object.entries(Ut))if(this.child.spinmatchv(e.family,s))return new U(new S(t,e.innerLayer,e.outerLayer),e.amount);return jt.isIdentical(e.quantum)?new U(dt,e.amount):re.isIdentical(e.quantum)?new U(dt,-e.amount):Ct.isIdentical(e.quantum)?new U(gt,e.amount):ae.isIdentical(e.quantum)?new U(gt,-e.amount):Pt.isIdentical(e.quantum)?new U(bt,e.amount):le.isIdentical(e.quantum)?new U(bt,-e.amount):null}};function ce(e,t){const s={...e,moves:{}};for(const[i,n]of Object.entries(e.moves)){let o=i,r="";["v","w"].includes(i.at(-1))&&(o=i.slice(0,-1),r=i.slice(-1));const u=t.notationToExternal(U.fromString(o));if(!u)continue;const l=u+r;if(!l)throw new Error(`Missing external move name for: ${i.toString()}`);s.moves[l.toString()]=n}return s}function Ie(e){let t=0;const s={};for(;t<e.length&&e[t][0]==="-";){const n=e[t++];if(n==="--rotations")s.addRotations=!0;else if(n==="--allmoves")s.allMoves=!0;else if(n==="--outerblockmoves")s.outerBlockMoves=!0;else if(n==="--vertexmoves")s.vertexMoves=!0;else if(n==="--nocorners")s.includeCornerOrbits=!1;else if(n==="--noedges")s.includeEdgeOrbits=!1;else if(n==="--noorientation")s.fixedOrientation=!0;else if(n==="--nocenters")s.includeCenterOrbits=!1;else if(n==="--omit")s.excludeOrbits=e[t].split(","),t++;else if(n==="--moves")s.moveList=e[t].split(","),t++;else if(n==="--optimize")s.optimizeOrbits=!0;else if(n==="--scramble")s.scrambleAmount=100;else if(n==="--fixcorner")s.fixedPieceType="v";else if(n==="--fixedge")s.fixedPieceType="e";else if(n==="--fixcenter")s.fixedPieceType="f";else if(n==="--orientcenters")s.orientCenters=!0;else if(n==="--puzzleorientation")s.puzzleOrientation=JSON.parse(e[t]),t++;else throw new Error(`Bad option: ${n}`)}return{puzzleDescription:Wt(e.slice(t).join(" ")),options:s}}var fe=class{constructor(e={}){b(this,"verbosity",0);b(this,"allMoves",!1);b(this,"outerBlockMoves");b(this,"vertexMoves",!1);b(this,"addRotations",!1);b(this,"moveList",null);b(this,"fixedOrientation",!1);b(this,"fixedPieceType",null);b(this,"orientCenters",!1);b(this,"includeCornerOrbits",!0);b(this,"includeCenterOrbits",!0);b(this,"includeEdgeOrbits",!0);b(this,"excludeOrbits",[]);b(this,"optimizeOrbits",!1);b(this,"grayCorners",!1);b(this,"grayCenters",!1);b(this,"grayEdges",!1);b(this,"puzzleOrientation",null);b(this,"puzzleOrientations",null);b(this,"scrambleAmount",0);Object.assign(this,e)}},vt=[],wt=[];function ot(e){if(!vt[e]){const t=Array(e);for(let s=0;s<e;s++)t[s]=0;vt[e]=t}return vt[e]}function st(e){if(!wt[e]){const t=Array(e);for(let s=0;s<e;s++)t[s]=s;wt[e]=t}return wt[e]}function ue(e){return new at(st(e))}function me(e){let t=BigInt(1);for(;e>1;)t*=BigInt(e),e--;return t}function pe(e,t){if(e>t){const s=e;e=t,t=s}for(;e>0;){const s=t%e;t=e,e=s}return t}function Nt(e,t){return e/pe(e,t)*t}var at=class ht{constructor(t){b(this,"n");b(this,"p");this.n=t.length,this.p=t}toString(){return`Perm[${this.p.join(" ")}]`}mul(t){const s=Array(this.n);for(let i=0;i<this.n;i++)s[i]=t.p[this.p[i]];return new ht(s)}rmul(t){const s=Array(this.n);for(let i=0;i<this.n;i++)s[i]=this.p[t.p[i]];return new ht(s)}inv(){const t=Array(this.n);for(let s=0;s<this.n;s++)t[this.p[s]]=s;return new ht(t)}compareTo(t){for(let s=0;s<this.n;s++)if(this.p[s]!==t.p[s])return this.p[s]-t.p[s];return 0}toGap(){const t=new Array,s=new Array(this.n);for(let i=0;i<this.p.length;i++){if(s[i]||this.p[i]===i)continue;const n=new Array;for(let o=this.p[i];!s[o];o=this.p[o])n.push(1+o),s[o]=!0;t.push(`(${n.reverse().join(",")})`)}return t.join("")}toMathematica(){const t=new Array,s=new Array(this.n);for(let i=0;i<this.p.length;i++){if(s[i]||this.p[i]===i)continue;const n=new Array;for(let o=this.p[i];!s[o];o=this.p[o])n.push(1+o),s[o]=!0;t.push(`{${n.reverse().join(",")}}`)}return`Cycles[{${t.join(",")}}]`}order(){let t=1;const s=new Array(this.n);for(let i=0;i<this.p.length;i++){if(s[i]||this.p[i]===i)continue;let n=0;for(let o=i;!s[o];o=this.p[o])n++,s[o]=!0;t=Nt(t,n)}return t}},Lt=class{constructor(e,t){this.size=e,this.mod=t}reassemblySize(){return me(this.size)*BigInt(this.mod)**BigInt(this.size)}},de=0;function ut(e,t){const s=U.fromString(t),i=e.notationToExternal(s);return i===null||s===i?t:i.toString()}var At=class Gt{constructor(t,s,i,n,o,r,u){this.orbitnames=t,this.orbitdefs=s,this.solved=i,this.movenames=n,this.moveops=o,this.isRotation=r,this.forcenames=u}toKTransformationData(t){const s={};for(let i=0;i<this.orbitnames.length;i++)s[this.orbitnames[i]]=t.orbits[i].toKTransformationOrbitData();return s}toKPatternData(t){const s={};for(let i=0;i<this.orbitnames.length;i++)s[this.orbitnames[i]]=t.orbits[i].toKPatternOrbitData();return s}static transformToKTransformationData(t,s){const i={};for(let n=0;n<t.length;n++)i[t[n]]=s.orbits[n].toKTransformationOrbitData();return i}describeSet(t,s,i){const n=this.orbitdefs[t].size,o=new Array(n);for(let r=0;r<n;r++)o[r]=[];for(let r=0;r<this.movenames.length;r++){if(this.isRotation[r])continue;let u=this.movenames[r];this.forcenames[r]||(u=ut(i,u),u[u.length-1]==="'"&&(u=u.substring(0,u.length-1)));const l=this.moveops[r].orbits[t];for(let h=0;h<n;h++)(l.perm[h]!==h||l.ori[h]!==0)&&o[h].push(u)}for(let r=0;r<n;r++)s.push(`# ${r+1} ${o[r].join(" ")}`)}toKsolve(t,s=new It){const i=[];i.push(`Name ${t}`),i.push("");for(let n=0;n<this.orbitnames.length;n++)i.push(`Set ${this.orbitnames[n]} ${this.orbitdefs[n].size} ${this.orbitdefs[n].mod}`),this.describeSet(n,i,s);i.push(""),i.push("Solved");for(let n=0;n<this.orbitnames.length;n++)this.solved.orbits[n].appendDefinition(i,this.orbitnames[n],!1,!1);i.push("End");for(let n=0;n<this.movenames.length;n++){i.push("");let o=this.movenames[n];this.forcenames[n]||(o=ut(s,this.movenames[n]));let r=!1;o[o.length-1]==="'"&&(r=!0,o=o.substring(0,o.length-1)),i.push(`Move ${o}`);for(let u=0;u<this.orbitnames.length;u++)r?this.moveops[n].orbits[u].inv().appendDefinition(i,this.orbitnames[u],!0):this.moveops[n].orbits[u].appendDefinition(i,this.orbitnames[u],!0);i.push("End")}return i}toKPuzzleDefinition(t){const s=[],i={};for(let o=0;o<this.orbitnames.length;o++){s.push({orbitName:this.orbitnames[o],numPieces:this.orbitdefs[o].size,numOrientations:this.orbitdefs[o].mod});const r=this.solved.orbits[o].toKTransformationOrbitData();i[this.orbitnames[o]]={pieces:r.permutation,orientation:r.orientationDelta}}const n={};if(t)for(let o=0;o<this.movenames.length;o++)n[this.movenames[o]]=this.toKTransformationData(this.moveops[o]);return{name:`PG3D #${++de}`,orbits:s,defaultPattern:i,moves:n}}optimize(){const t=[],s=[],i=[],n=[];for(let o=0;o<this.moveops.length;o++)n.push([]);for(let o=0;o<this.orbitdefs.length;o++){const r=this.orbitdefs[o].mod,u=this.orbitdefs[o].size,l=new Ot(u),h=new Array(this.orbitdefs[o].size);for(let m=0;m<u;m++)h[m]=!1;for(let m=0;m<this.moveops.length;m++)for(let a=0;a<u;a++)(this.moveops[m].orbits[o].perm[a]!==a||this.moveops[m].orbits[o].ori[a]!==0)&&(this.isRotation[m]||(h[a]=!0),l.union(a,this.moveops[m].orbits[o].perm[a]));let v=!0;if(r>1){v=!1;const m=new Ot(this.orbitdefs[o].size*r);for(let a=0;a<this.moveops.length;a++)for(let f=0;f<u;f++)if(this.moveops[a].orbits[o].perm[f]!==f||this.moveops[a].orbits[o].ori[f]!==0)for(let y=0;y<r;y++)m.union(f*r+y,this.moveops[a].orbits[o].perm[f]*r+(y+this.moveops[a].orbits[o].ori[f])%r);for(let a=0;!v&&a<u;a++)for(let f=1;f<r;f++)m.find(a*r)===m.find(a*r+f)&&(v=!0);for(let a=0;!v&&a<u;a++)for(let f=0;f<a;f++)this.solved.orbits[o].perm[a]===this.solved.orbits[o].perm[f]&&(v=!0)}let d=-1,w=!1;for(let m=0;m<this.orbitdefs[o].size;m++)if(h[m]){const a=l.find(m);d<0?d=a:d!==a&&(w=!0)}for(let m=0;m<this.orbitdefs[o].size;m++){if(!h[m]||l.find(m)!==m)continue;const f=[],y=[];let L=0;for(let g=0;g<this.orbitdefs[o].size;g++)l.find(g)===m&&(f[L]=g,y[g]=L,L++);if(w?t.push(`${this.orbitnames[o]}_p${m}`):t.push(this.orbitnames[o]),v){s.push(new Lt(L,this.orbitdefs[o].mod)),i.push(this.solved.orbits[o].remapVS(f,L));for(let g=0;g<this.moveops.length;g++)n[g].push(this.moveops[g].orbits[o].remap(f,y,L))}else{s.push(new Lt(L,1)),i.push(this.solved.orbits[o].remapVS(f,L).killOri());for(let g=0;g<this.moveops.length;g++)n[g].push(this.moveops[g].orbits[o].remap(f,y,L).killOri())}}}return new Gt(t,s,new Ht(i),this.movenames,n.map(o=>new Qt(o)),this.isRotation,this.forcenames)}scramble(t){this.solved=this.solved.mul(this.getScrambleTransformation(t))}getScrambleTransformation(t){t<100&&(t=100);const s=[];for(let n=0;n<this.moveops.length;n++)s[n]=this.moveops[n];for(let n=0;n<s.length;n++){const o=Math.floor(Math.random()*s.length),r=s[n];s[n]=s[o],s[o]=r}t<s.length&&(t=s.length);for(let n=0;n<t;n++){const o=Math.floor(Math.random()*s.length),r=Math.floor(Math.random()*s.length),u=Math.floor(Math.random()*this.moveops.length);s[o]=s[o].mul(s[r]).mul(this.moveops[u]),Math.random()<.1&&(s[o]=s[o].mul(this.moveops[u]))}let i=s[0];for(let n=1;n<s.length;n++)i=i.mul(s[n]);return i}reassemblySize(){let t=BigInt(1);for(let s=0;s<this.orbitdefs.length;s++)t*=this.orbitdefs[s].reassemblySize();return t}},et,rt=(et=class{constructor(t,s,i){this.perm=t,this.ori=s,this.orimod=i}static e(t,s){return new et(st(t),ot(t),s)}mul(t){const s=this.perm.length,i=new Array(s);if(this.orimod===1){for(let n=0;n<s;n++)i[n]=this.perm[t.perm[n]];return new et(i,this.ori,this.orimod)}else{const n=new Array(s);for(let o=0;o<s;o++)i[o]=this.perm[t.perm[o]],n[o]=(this.ori[t.perm[o]]+t.ori[o])%this.orimod;return new et(i,n,this.orimod)}}inv(){const t=this.perm.length,s=new Array(t),i=new Array(t);for(let n=0;n<t;n++)s[this.perm[n]]=n,i[this.perm[n]]=(this.orimod-this.ori[n])%this.orimod;return new et(s,i,this.orimod)}equal(t){const s=this.perm.length;for(let i=0;i<s;i++)if(this.perm[i]!==t.perm[i]||this.ori[i]!==t.ori[i])return!1;return!0}killOri(){const t=this.perm.length;for(let s=0;s<t;s++)this.ori[s]=0;return this.orimod=1,this}toPerm(){const t=this.orimod;if(t===1)return new at(this.perm);const s=this.perm.length,i=new Array(s*t);for(let n=0;n<s;n++)for(let o=0;o<t;o++)i[n*t+o]=t*this.perm[n]+(this.ori[n]+o)%t;return new at(i)}identicalPieces(){const t=[],s=this.perm.length,i=[];for(let n=0;n<s;n++){const o=this.perm[n];if(t[o]===void 0){const r=[n];t[o]=!0;for(let u=n+1;u<s;u++)this.perm[u]===o&&r.push(u);i.push(r)}}return i}order(){return this.toPerm().order()}isIdentity(){const t=this.perm.length;if(this.perm===st(t)&&this.ori===ot(t))return!0;for(let s=0;s<t;s++)if(this.perm[s]!==s||this.ori[s]!==0)return!1;return!0}zeroOris(){const t=this.perm.length;if(this.ori===ot(t))return!0;for(let s=0;s<t;s++)if(this.ori[s]!==0)return!1;return!0}remap(t,s,i){const n=new Array(i),o=new Array(i);for(let r=0;r<i;r++)n[r]=s[this.perm[t[r]]],o[r]=this.ori[t[r]];return new et(n,o,this.orimod)}remapVS(t,s){const i=new Array(s),n=new Array(s);let o=0;const r=[];for(let u=0;u<s;u++){const l=this.perm[t[u]];r[l]===void 0&&(r[l]=o++),i[u]=r[l],n[u]=this.ori[t[u]]}return new et(i,n,this.orimod)}appendDefinition(t,s,i,n=!0){if(!(n&&this.isIdentity())&&(t.push(s),t.push(this.perm.map(o=>o+1).join(" ")),!this.zeroOris()))if(i){const o=new Array(this.ori.length);for(let r=0;r<o.length;r++)o[this.perm[r]]=this.ori[r];t.push(o.join(" "))}else t.push(this.ori.join(" "))}toKTransformationOrbitData(){const t=this.perm.length;return this.isIdentity()?(et.ktransformationCache[t]||(et.ktransformationCache[t]={permutation:st(t),orientationDelta:ot(t)}),et.ktransformationCache[t]):{permutation:this.perm,orientationDelta:this.ori}}toKPatternOrbitData(){const t=this.perm.length;return{pieces:this.perm,orientation:this.ori,orientationMod:ot(t)}}},b(et,"ktransformationCache",[]),et),Kt=class{constructor(e){this.orbits=e}internalMul(e){const t=[];for(let s=0;s<this.orbits.length;s++)t.push(this.orbits[s].mul(e.orbits[s]));return t}internalInv(){const e=[];for(const t of this.orbits)e.push(t.inv());return e}equal(e){for(let t=0;t<this.orbits.length;t++)if(!this.orbits[t].equal(e.orbits[t]))return!1;return!0}killOri(){for(const e of this.orbits)e.killOri();return this}toPerm(){const e=new Array;let t=0;for(const i of this.orbits){const n=i.toPerm();e.push(n),t+=n.n}const s=new Array(t);t=0;for(const i of e){for(let n=0;n<i.n;n++)s[t+n]=t+i.p[n];t+=i.n}return new at(s)}identicalPieces(){const e=[];let t=0;for(const s of this.orbits){const i=s.orimod,n=s.identicalPieces();for(let o=0;o<n.length;o++)e.push(n[o].map(r=>r*i+t));t+=i*s.perm.length}return e}order(){let e=1;for(const t of this.orbits)e=Nt(e,t.order());return e}},Qt=class ct extends Kt{mul(t){return new ct(this.internalMul(t))}mulScalar(t){if(t===0)return this.e();let s=this;for(t<0&&(s=s.inv(),t=-t);!(t&1);)s=s.mul(s),t>>=1;if(t===1)return s;let i=s,n=this.e();for(;t>0;)t&1&&(n=n.mul(i)),t>1&&(i=i.mul(i)),t>>=1;return n}inv(){return new ct(this.internalInv())}e(){return new ct(this.orbits.map(t=>rt.e(t.perm.length,t.orimod)))}},Ht=class Zt extends Kt{mul(t){return new Zt(this.internalMul(t))}},Ot=class{constructor(e){b(this,"heads");this.n=e,this.heads=new Array(e);for(let t=0;t<e;t++)this.heads[t]=t}find(e){let t=this.heads[e];return this.heads[t]===t||(t=this.find(this.heads[t]),this.heads[e]=t),t}union(e,t){const s=this.find(e),i=this.find(t);s<i?this.heads[i]=s:s>i&&(this.heads[s]=i)}};function ge(e,t){const s=e.moveops.length;if(s>30)throw new Error("Canon info too big for bitmask");const i=[],n=[];for(let r=0;r<s;r++){const u=e.moveops[r];i.push(u.order());let l=0;for(let h=0;h<s;h++){if(h===r)continue;const v=e.moveops[h];u.mul(v).equal(v.mul(u))&&(l|=1<<h)}n.push(l)}let o={};o[0]=1;for(let r=0;r<100;r++){let u=0;const l={};let h=0;for(const v in o){const d=+v,w=o[d];u+=w,h++;for(let m=0;m<i.length;m++)if(!(d>>m&1)&&!(d&n[m]&(1<<m)-1)){const a=d&n[m]|1<<m;l[a]===void 0&&(l[a]=0),l[a]+=(i[m]-1)*w}}t(`${r}: canonseq ${u} states ${h}`),o=l}}var Mt={"2x2x2":"c f 0","3x3x3":"c f 0.333333333333333","4x4x4":"c f 0.5 f 0","5x5x5":"c f 0.6 f 0.2","6x6x6":"c f 0.666666666666667 f 0.333333333333333 f 0","7x7x7":"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143","8x8x8":"c f 0.75 f 0.5 f 0.25 f 0","9x9x9":"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111","10x10x10":"c f 0.8 f 0.6 f 0.4 f 0.2 f 0","11x11x11":"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909","12x12x12":"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0","13x13x13":"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769","20x20x20":"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9","30x30x30":"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333","40x40x40":"c f 0 f .05 f .1 f .15 f .2 f .25 f .3 f .35 f .4 f .45 f .5 f .55 f .6 f .65 f .7 f .75 f .8 f .85 f .9 f .95",skewb:"c v 0","master skewb":"c v 0.275","professor skewb":"c v 0 v 0.38","compy cube":"c v 0.915641442663986",helicopter:"c e 0.707106781186547","curvy copter":"c e 0.83",dino:"c v 0.577350269189626","little chop":"c e 0",pyramorphix:"t e 0",mastermorphix:"t e 0.346184634065199",pyraminx:"t v 0.333333333333333 v 1.66666666666667",tetraminx:"t v 0.333333333333333","master pyraminx":"t v 0 v 1 v 2","master tetraminx":"t v 0 v 1","professor pyraminx":"t v -0.2 v 0.6 v 1.4 v 2.2","professor tetraminx":"t v -0.2 v 0.6 v 1.4","royal pyraminx":"t v -0.333333333333333 v 0.333333333333333 v 1 v 1.66666666666667 v 2.33333333333333","royal tetraminx":"t v -0.333333333333333 v 0.333333333333333 v 1 v 1.66666666666667","emperor pyraminx":"t v -0.428571428571429 v 0.142857142857143 v 0.714285714285714 v 1.28571428571429 v 1.85714285714286 v 2.42857142857143","emperor tetraminx":"t v -0.428571428571429 v 0.142857142857143 v 0.714285714285714 v 1.28571428571429 v 1.85714285714286","Jing pyraminx":"t f 0","master pyramorphix":"t e 0.866025403784437",megaminx:"d f 0.7",gigaminx:"d f 0.64 f 0.82",teraminx:"d f 0.64 f 0.76 f 0.88",petaminx:"d f 0.64 f 0.73 f 0.82 f 0.91",examinx:"d f 0.64 f 0.712 f 0.784 f 0.856 f 0.928",zetaminx:"d f 0.64 f 0.7 f 0.76 f 0.82 f 0.88 f 0.94",yottaminx:"d f 0.64 f 0.6914 f 0.7429 f 0.7943 f 0.8457 f 0.8971 f 0.9486",pentultimate:"d f 0","master pentultimate":"d f 0.1","elite pentultimate":"d f 0 f 0.145905",starminx:"d v 0.937962370425399","starminx 2":"d f 0.23606797749979","pyraminx crystal":"d f 0.447213595499989",chopasaurus:"d v 0","big chop":"d e 0","skewb diamond":"o f 0",FTO:"o f 0.333333333333333","master FTO":"o f 0.5 f 0","Christopher's jewel":"o v 0.577350269189626",octastar:"o e 0","Trajber's octahedron":"o v 0.433012701892219","radio chop":"i f 0",icosamate:"i v 0","Regular Astrominx":"i v 0.18759247376021","Regular Astrominx + Big Chop":"i v 0.18759247376021 e 0",Redicosahedron:"i v 0.794654472291766","Redicosahedron with centers":"i v 0.84",Icosaminx:"i v 0.73","Eitan's star":"i f 0.61803398874989","2x2x2 + dino":"c f 0 v 0.577350269189626","2x2x2 + little chop":"c f 0 e 0","dino + little chop":"c v 0.577350269189626 e 0","2x2x2 + dino + little chop":"c f 0 v 0.577350269189626 e 0","megaminx + chopasaurus":"d f 0.61803398875 v 0","starminx combo":"d f 0.23606797749979 v 0.937962370425399"},nt=1e-9;function yt(e){let t=new H(0,0,0,0);for(let s=0;s<e.length;s++)t=t.sum(e[s]);return t.smul(1/e.length)}function be(e,t,s,i){const n=i[e].intersect3(i[t],i[s]);if(!n)return n;for(let o=0;o<i.length;o++)if(o!==e&&o!==t&&o!==s){const r=i[o].b*n.b+i[o].c*n.c+i[o].d*n.d;if(i[o].a>0&&r>i[o].a||i[o].a<0&&r<i[o].a)return!1}return n}var H=class q{constructor(t,s,i,n){this.a=t,this.b=s,this.c=i,this.d=n}mul(t){return new q(this.a*t.a-this.b*t.b-this.c*t.c-this.d*t.d,this.a*t.b+this.b*t.a+this.c*t.d-this.d*t.c,this.a*t.c-this.b*t.d+this.c*t.a+this.d*t.b,this.a*t.d+this.b*t.c-this.c*t.b+this.d*t.a)}toString(){return`Q[${this.a},${this.b},${this.c},${this.d}]`}dist(t){return Math.hypot(this.a-t.a,this.b-t.b,this.c-t.c,this.d-t.d)}len(){return Math.hypot(this.a,this.b,this.c,this.d)}cross(t){return new q(0,this.c*t.d-this.d*t.c,this.d*t.b-this.b*t.d,this.b*t.c-this.c*t.b)}dot(t){return this.b*t.b+this.c*t.c+this.d*t.d}normalize(){const t=Math.sqrt(this.dot(this));return new q(this.a/t,this.b/t,this.c/t,this.d/t)}makenormal(){return new q(0,this.b,this.c,this.d).normalize()}normalizeplane(){const t=Math.hypot(this.b,this.c,this.d);return new q(this.a/t,this.b/t,this.c/t,this.d/t)}smul(t){return new q(this.a*t,this.b*t,this.c*t,this.d*t)}sum(t){return new q(this.a+t.a,this.b+t.b,this.c+t.c,this.d+t.d)}sub(t){return new q(this.a-t.a,this.b-t.b,this.c-t.c,this.d-t.d)}angle(){return 2*Math.acos(this.a)}invrot(){return new q(this.a,-this.b,-this.c,-this.d)}det3x3(t,s,i,n,o,r,u,l,h){return t*(o*h-r*l)+s*(r*u-n*h)+i*(n*l-o*u)}rotateplane(t){const s=t.mul(new q(0,this.b,this.c,this.d)).mul(t.invrot());return s.a=this.a,s}orthogonal(){const t=Math.abs(this.b),s=Math.abs(this.c),i=Math.abs(this.d);return t<s&&t<i?this.cross(new q(0,1,0,0)).normalize():s<t&&s<i?this.cross(new q(0,0,1,0)).normalize():this.cross(new q(0,0,0,1)).normalize()}pointrotation(t){const s=this.normalize();if(t=t.normalize(),s.sub(t).len()<nt)return new q(1,0,0,0);let i=s.sum(t);i.len()<nt?i=i.orthogonal():i=i.normalize();const n=s.cross(i);return n.a=s.dot(i),n}unproject(t){return this.sum(t.smul(-this.dot(t)/(this.len()*t.len())))}rotatepoint(t){return t.mul(this).mul(t.invrot())}rotateface(t){return t.map(s=>s.rotatepoint(this))}intersect3(t,s){const i=this.det3x3(this.b,this.c,this.d,t.b,t.c,t.d,s.b,s.c,s.d);return Math.abs(i)<nt?!1:new q(0,this.det3x3(this.a,this.c,this.d,t.a,t.c,t.d,s.a,s.c,s.d)/i,this.det3x3(this.b,this.a,this.d,t.b,t.a,t.d,s.b,s.a,s.d)/i,this.det3x3(this.b,this.c,this.a,t.b,t.c,t.a,s.b,s.c,s.a)/i)}side(t){return t>nt?1:t<-nt?-1:0}cutface(t){const s=this.a;let i=0,n=null;for(let o=0;o<t.length;o++)i|=1<<this.side(t[o].dot(this)-s)+1;if((i&5)===5){n=[];const o=t.map(r=>this.side(r.dot(this)-s));for(let r=-1;r<=1;r+=2){const u=[];for(let l=0;l<t.length;l++){(o[l]===r||o[l]===0)&&u.push(t[l]);const h=(l+1)%t.length;if(o[l]+o[h]===0&&o[l]!==0){const v=t[l].dot(this)-s,d=t[h].dot(this)-s,w=v/(v-d),m=t[l].smul(1-w).sum(t[h].smul(w));u.push(m)}}n.push(u)}}return n}cutfaces(t){const s=[];for(let i=0;i<t.length;i++){const n=t[i],o=this.cutface(n);o?(s.push(o[0]),s.push(o[1])):s.push(n)}return s}faceside(t){const s=this.a;for(let i=0;i<t.length;i++){const n=this.side(t[i].dot(this)-s);if(n!==0)return n}throw new Error("Could not determine side of plane in faceside")}sameplane(t){const s=this.normalize(),i=t.normalize();return s.dist(i)<nt||s.dist(i.smul(-1))<nt}makecut(t){return new q(t,this.b,this.c,this.d)}},mt=1e-9;function ve(){const e=Math.sqrt(.5);return[new H(e,e,0,0),new H(e,0,e,0)]}function we(){return[new H(.5,.5,.5,.5),new H(.5,.5,.5,-.5)]}function ye(){const e=2*Math.PI/10;let t=.5+.3*Math.sqrt(5),s=.5+.1*Math.sqrt(5);const i=Math.sqrt(t*t+s*s);return t/=i,s/=i,[new H(Math.cos(e),t*Math.sin(e),s*Math.sin(e),0),new H(.5,.5,.5,.5)]}function xe(){let e=.16666666666666666+Math.sqrt(5)/6,t=2/3+Math.sqrt(5)/3;const s=Math.sqrt(e*e+t*t);e/=s,t/=s;const i=2*Math.PI/6;return[new H(Math.cos(i),e*Math.sin(i),t*Math.sin(i),0),new H(Math.cos(i),-e*Math.sin(i),t*Math.sin(i),0)]}function Le(){const e=Math.sqrt(.5);return[new H(.5,.5,.5,.5),new H(e,0,0,e)]}function Be(e){const t=[new H(1,0,0,0)];for(let s=0;s<t.length;s++)for(let i=0;i<e.length;i++){const n=e[i].mul(t[s]),o=n.smul(-1);let r=!1;for(let u=0;u<t.length;u++)if(n.dist(t[u])<mt||o.dist(t[u])<mt){r=!0;break}r||t.push(n)}return t}function $t(e,t){const s=[],i=[];for(let n=0;n<t.length;n++){const o=e.rotateplane(t[n]);let r=!1;for(let u=0;u<s.length;u++)if(o.dist(s[u])<mt){r=!0;break}r||(s.push(o),i.push(t[n]))}return i}function St(e){const t=[];for(let s=1;s<e.length;s++)for(let i=s+1;i<e.length;i++){const n=be(0,s,i,e);if(n){let o=!1;for(let r=0;r<t.length;r++)if(n.dist(t[r])<mt){o=!0;break}o||t.push(n)}}for(;;){let s=!1;for(let i=0;i<t.length;i++){const n=(i+1)%t.length;if(e[0].dot(t[i].cross(t[n]))<0){const o=t[i];t[i]=t[n],t[n]=o,s=!0}}if(!s)break}return t}var Fe=class{constructor(){b(this,"mult");this.mult=[]}multiply(e){for(let t=2;t*t<=e;t++)for(;e%t===0;)this.mult[t]!==void 0?this.mult[t]++:this.mult[t]=1,e/=t;e>1&&(this.mult[e]!==void 0?this.mult[e]++:this.mult[e]=1)}toString(){let e="";for(let t=0;t<this.mult.length;t++)this.mult[t]!==void 0&&(e!==""&&(e+="*"),e+=t,this.mult[t]>1&&(e+=`^${this.mult[t]}`));return e}};function Re(e,t){const s=e[0].p.length,i=ue(s);let n=[],o=[],r=[],u=[],l=[];function h(m){for(let a=m.p.length-1;a>=0;a--){const f=m.p[a];if(f!==a){if(!n[a][f])return!1;m=m.mul(o[a][f])}}return!0}function v(m,a,f){u[m].push(a),l[m].push(f);for(let y=0;y<n[m].length;y++)n[m][y]&&d(m,n[m][y].mul(a),f+r[m][y])}function d(m,a,f){const y=a.p[m];if(!n[m][y]){n[m][y]=a,o[m][y]=a.inv(),r[m][y]=f;for(let g=0;g<u[m].length;g++)d(m,a.mul(u[m][g]),f+l[m][g]);return}const L=a.mul(o[m][y]);h(L)||v(m-1,L,f+r[m][y])}function w(){n=[],o=[],u=[],r=[],l=[];for(let f=0;f<s;f++)n.push([]),o.push([]),r.push([]),u.push([]),l.push([]),n[f][f]=i,o[f][f]=i,r[f][f]=0;let m=0,a=BigInt(1);for(let f=0;f<e.length;f++){v(s-1,e[f],1),a=BigInt(1);let y=0,L=0;const g=new Fe;for(let B=0;B<s;B++){let M=0,N=0;for(let I=0;I<s;I++)n[B][I]&&(M++,N+=r[B][I],B!==I&&m++);y+=u[B].length,a*=BigInt(M),M>1&&g.multiply(M);const Y=N/M;L+=Y}t(`${f}: sz ${a} T ${y} sol ${L} none ${m} mults ${g.toString()}`)}return a}return w()}var Bt=class Ft{constructor(t){b(this,"coords");b(this,"length");this.coords=new Array(t.length*3);for(let s=0;s<t.length;s++)this.coords[3*s]=t[s].b,this.coords[3*s+1]=t[s].c,this.coords[3*s+2]=t[s].d;this.length=t.length}get(t){return new H(0,this.coords[3*t],this.coords[3*t+1],this.coords[3*t+2])}centermass(){let t=0,s=0,i=0;for(let n=0;n<this.length;n++)t+=this.coords[3*n],s+=this.coords[3*n+1],i+=this.coords[3*n+2];return new H(0,t/this.length,s/this.length,i/this.length)}rotate(t){const s=[];for(let i=0;i<this.length;i++)s.push(this.get(i).rotatepoint(t));return new Ft(s)}rotateforward(){const t=[];for(let s=1;s<this.length;s++)t.push(this.get(s));return t.push(this.get(0)),new Ft(t)}},Me=class Rt{constructor(t,s,i){this.face=t,this.left=s,this.right=i}split(t){var i,n;const s=t.cutface(this.face);return s!==null&&(this.left===void 0?(this.left=new Rt(s[0]),this.right=new Rt(s[1])):(this.left=(i=this.left)==null?void 0:i.split(t),this.right=(n=this.right)==null?void 0:n.split(t))),this}collect(t,s){var i,n,o,r;return this.left===void 0?t.push(new Bt(this.face)):s?((i=this.left)==null||i.collect(t,!1),(n=this.right)==null||n.collect(t,!0)):((o=this.right)==null||o.collect(t,!1),(r=this.left)==null||r.collect(t,!0)),t}};function De(e,t){const s=[];for(const i of e)for(const n of t)s.push(n.rotate(i));return s}var W=1e-9,ze="PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.";function ke(){return{4:[["F","D","L","R"]],6:[["F","D","L","U","R"],["R","F","","B",""]],8:[["F","D","L","R"],["D","F","BR",""],["BR","D","","BB"],["BB","BR","U","BL"]],12:[["U","F","","","",""],["F","U","R","C","A","L"],["R","F","","","E",""],["E","R","","BF","",""],["BF","E","BR","BL","I","D"]],20:[["R","C","F","E"],["F","R","L","U"],["L","F","A",""],["E","R","G","I"],["I","E","S","H"],["S","I","J","B"],["B","S","K","D"],["K","B","M","O"],["O","K","P","N"],["P","O","Q",""]]}}var Ee={4:{v:["DFR","DLF","DRL","FLR"],e:["FR","LF","DF","DL","RD","RL"],c:["DF","FD","RL","LR"]},6:{v:["URF","UBR","ULB","UFL","DFR","DRB","DBL","DLF"],e:["UF","UR","UB","UL","DF","DR","DB","DL","FR","FL","BR","BL"],c:["UB","LU","FU","RU","BU","DF"]},8:{v:["UBBBRR","URFL","ULBLBB","DBRBBBL","DBLLF","DFRBR"],e:["UL","UBB","UR","BRD","BLD","FD","BRR","FR","FL","BLL","BLBB","BRBB"],c:["BBU","LU","RU","BRD","FD","BLD","DF","UBB"]},12:{v:["URF","UFL","ULBL","UBLBR","UBRR","DEBF","DBFI","DIA","DAC","DCE","LAI","ALF","FCA","CFR","REC","ERBR","BRBFE","BFBRBL","BLIBF","IBLL"],e:["UF","UR","UBR","UBL","UL","ER","EBR","EBF","ED","EC","IBF","IBL","IL","IA","ID","AC","CF","FA","BFBR","BRBL","BLBF","CD","AD","AL","FL","FR","CR","BFD","BRR","BLL"],c:["UF","FU","DBF","BFD","AD","CD","BRU","BLU","LA","RA","EBR","IBL"]},20:{v:["FLPQU","FUGER","FRCAL","HCREI","ISBDH","JSIEG","BSJMK","MQPOK","ONDBK","NOPLA","UQMJG","DNACH"],e:["FU","FL","FR","EG","ER","EI","SJ","SI","SB","KM","KB","KO","PQ","PO","PL","UG","JG","MQ","UQ","HC","HD","ND","NA","JM","CA","AL","CR","HI","DB","NO"],c:["FU","UF","GE","EG","JS","SJ","MK","KM","QP","PQ","LA","AL","RC","CR","IH","HI","BD","DB","ON","NO"]}};function Ue(){return{4:[["FLR",[0,1,0]],["F",[0,0,1]]],6:[["U",[0,1,0]],["F",[0,0,1]]],8:[["U",[0,1,0]],["F",[0,0,1]]],12:[["U",[0,1,0]],["F",[0,0,1]]],20:[["GUQMJ",[0,1,0]],["F",[0,0,1]]]}}function lt(e,t){for(let s=0;s<e.length;s++)if(e[s][0].dist(t)<W)return s;throw Error("Element not found")}function Te(){return Mt}function Ne(e){return Mt[e]}var Ae=["c","t","o","d","i"],Ge=["f","v","e"];function Wt(e){const t=e.split(/ /).filter(Boolean);if(t.length%2===0)return null;const s=t[0];if(s!=="o"&&s!=="c"&&s!=="i"&&s!=="d"&&s!=="t")return null;const i=[];for(let n=1;n<t.length;n+=2){if(t[n]!=="f"&&t[n]!=="v"&&t[n]!=="e")return null;i.push({cutType:t[n],distance:parseFloat(t[n+1])})}return{shape:s,cuts:i}}function je(e,t={}){const s=Wt(e);if(s===null)throw Error("Could not parse the puzzle description");const i=new Oe(s,Object.assign({},{allMoves:!0},t));return i.allstickers(),i.genperms(),i}function Ke(e,t){return je(Mt[e],t)}function Ce(e,t,s){let i=!1;s-t[1]<t[0]&&(e=[e[2],e[3],e[0],e[1]],t=[s-t[1],s-t[0]],i=!0);let n=e[0],o="";if(t[0]===0&&t[1]===s)n=`${n}v`;else if(t[0]===t[1])t[1]>0&&(o=String(t[1]+1));else if(t[0]===0)n=n.toLowerCase(),t[1]>1&&(o=String(t[1]+1));else throw Error(`We only support slice and outer block moves right now. ${t}`);return[o+n,i]}function Pe(e,t){const s=[];let i=0;for(;i<e.length;){i>0&&i<e.length&&e[i]==="_"&&i++;let n="";for(const o of t)e.substr(i).startsWith(o[1])&&o[1].length>n.length&&(n=o[1]);if(n!=="")s.push(n),i+=n.length;else throw Error(`Could not split ${e} into face names.`)}return s}function ft(e,t){return[e.b/t,-e.c/t,e.d/t]}function xt(e,t){const s=[],i=e.length;for(let n=0;n<i;n++){const o=ft(e.get(i-n-1),t);s[3*n]=o[0],s[3*n+1]=o[1],s[3*n+2]=o[2]}return s}var Oe=class{constructor(e,t){b(this,"rotations");b(this,"baseplanerot");b(this,"baseplanes");b(this,"facenames");b(this,"faceplanes");b(this,"edgenames");b(this,"vertexnames");b(this,"geonormals");b(this,"moveplanes");b(this,"moveplanes2");b(this,"moveplanesets");b(this,"moveplanenormals");b(this,"movesetorders");b(this,"movesetgeos");b(this,"basefaces");b(this,"faces");b(this,"facecentermass");b(this,"baseFaceCount");b(this,"stickersperface");b(this,"shortedge");b(this,"markedface");b(this,"cubies");b(this,"vertexdistance");b(this,"edgedistance");b(this,"facetocubie");b(this,"facetoord");b(this,"moverotations");b(this,"facelisthash");b(this,"cubiesetnames");b(this,"cubieords");b(this,"cubiesetnums");b(this,"cubieordnums");b(this,"orbitoris");b(this,"cubievaluemap");b(this,"cubiesetcubies");b(this,"cmovesbyslice",[]);b(this,"parsedmovelist");b(this,"duplicatedFaces",[]);b(this,"duplicatedCubies",[]);b(this,"fixedCubie",-1);b(this,"net",[]);b(this,"colors",[]);b(this,"swizzler");b(this,"notationMapper",new It);b(this,"addNotationMapper","");b(this,"setReidOrSpeffzOrder",!1);b(this,"options");this.puzzleDescription=e,this.options=new fe(t),this.options.verbosity>0&&console.log(this.header("# ")),this.create(e)}create(e){const{shape:t,cuts:s}=e;this.moveplanes=[],this.moveplanes2=[],this.faces=[],this.cubies=[];let i=null;switch(t){case"c":{i=ve();break}case"o":{i=Le();break}case"i":{i=xe();break}case"t":{i=we();break}case"d":{i=ye();break}default:throw Error(`Bad shape argument: ${t}`)}this.rotations=Be(i),this.options.verbosity&&console.log(`# Rotations: ${this.rotations.length}`);const n=i[0];this.baseplanerot=$t(n,this.rotations);const o=this.baseplanerot.map(c=>n.rotateplane(c));this.baseplanes=o,this.baseFaceCount=o.length;const r=ke()[o.length];this.net=r,this.colors=_t()[o.length],this.options.verbosity>0&&console.log(`# Base planes: ${o.length}`);const u=St(o),l=new H(0,0,0,0);this.options.verbosity>0&&console.log(`# Face vertices: ${u.length}`);const h=o[0].makenormal(),v=u[0].sum(u[1]).makenormal(),d=u[0].makenormal(),w=new H(1,h.b,h.c,h.d);this.options.verbosity>0&&console.log(`# Boundary is ${w}`);const a=$t(w,this.rotations).map(c=>w.rotateplane(c)),f=St(a);this.edgedistance=f[0].sum(f[1]).smul(.5).dist(l),this.vertexdistance=f[0].dist(l);const y=[],L=[];let g=!1,B=!1,M=!1;for(const c of s){let x=null,j=0;switch(c.cutType){case"f":{x=h,j=1,g=!0;break}case"v":{x=d,j=this.vertexdistance,M=!0;break}case"e":{x=v,j=this.edgedistance,B=!0;break}default:throw Error(`Bad cut argument: ${c.cutType}`)}y.push(x.makecut(c.distance)),L.push(c.distance<j)}this.options.addRotations&&(g||y.push(h.makecut(10)),M||y.push(d.makecut(10)),B||y.push(v.makecut(10))),this.basefaces=[];for(const c of this.baseplanerot){const x=c.rotateface(f);this.basefaces.push(new Bt(x))}const N=[],Y=[],I=[],p=[],F=f.length;function P(c,x,j){for(const E of c)if(E[0].dist(x)<W){E.push(j);return}c.push([x,j])}for(let c=0;c<this.baseplanerot.length;c++){const x=this.baseplanerot[c].rotateface(f);for(let j=0;j<x.length;j++){const E=(j+1)%x.length,$=x[j].sum(x[E]).smul(.5);P(p,$,c)}}const C=[];for(let c=0;c<this.baseplanerot.length;c++){const x=this.baseplanerot[c].rotateface(f),j=[];for(let E=0;E<x.length;E++){const $=(E+1)%x.length,G=x[E].sum(x[$]).smul(.5),V=p[lt(p,G)];if(c===V[1])j.push(V[2]);else if(c===V[2])j.push(V[1]);else throw Error("Could not find edge")}C.push(j)}const R={},D=[];D.push(r[0][0]),R[r[0][0]]=0,D[C[0][0]]=r[0][1],R[r[0][1]]=C[0][0];for(const c of r){const x=c[0],j=R[x];if(j===void 0)throw Error("Bad edge description; first edge not connected");let E=-1;for(let $=0;$<C[j].length;$++){const G=D[C[j][$]];if(G!==void 0&&G===c[1]){E=$;break}}if(E<0)throw Error("First element of a net not known");for(let $=2;$<c.length;$++){if(c[$]==="")continue;const G=C[j][($+E-1)%F],V=D[G];if(V!==void 0&&V!==c[$])throw Error("Face mismatch in net");D[G]=c[$],R[c[$]]=G}}for(let c=0;c<this.baseplanerot.length;c++){const x=this.baseplanerot[c].rotateface(f),j=w.rotateplane(this.baseplanerot[c]),E=D[c];N.push([x,E]),Y.push([j,E])}for(let c=0;c<this.baseplanerot.length;c++){const x=this.baseplanerot[c].rotateface(f),j=D[c];for(let E=0;E<x.length;E++){const $=(E+1)%x.length,G=x[E].sum(x[$]).smul(.5),V=(E+2)%x.length,Jt=x[$].sum(x[V]).smul(.5),Vt=lt(p,G),Yt=lt(p,Jt);P(I,x[$],[j,Yt,Vt])}}this.swizzler=new pt(N.map(c=>c[1]));const z=this.swizzler.prefixFree?"":"_",T=Ee[this.baseFaceCount],k=[];for(let c=0;c<this.baseFaceCount;c++)k[1<<c]=c;{const c=T.v;for(const x of c){const j=this.swizzler.splitByFaceNames(x);let E=0;for(const $ of j)E|=1<<$;k[E]=j[0]}}{const c=T.e;for(const x of c){const j=this.swizzler.splitByFaceNames(x);let E=0;for(const $ of j)E|=1<<$;k[E]=j[0]}}{const c=T.c;for(const x of c){const j=this.swizzler.splitByFaceNames(x),E=1<<j[0]|1<<this.baseFaceCount;k[E]=j[1]}}for(let c=0;c<p.length;c++){if(p[c].length!==3)throw Error(`Bad length in edge names ${p[c]}`);const x=p[c][1],j=p[c][2];let E=D[x];const $=D[j],G=1<<x|1<<j;k[G]===x?E=E+z+$:E=$+z+E,p[c]=[p[c][0],E]}for(let c=0;c<I.length;c++){let x=0;if(I[c].length<4)throw Error("Bad length in vertex names");for(let G=1;G<I[c].length;G++)x|=1<<R[I[c][G][0]];const j=k[x];let E=-1;for(let G=1;G<I[c].length;G++)j===R[I[c][G][0]]&&(E=G);if(E<0)throw Error("Internal error; couldn't find face name when fixing corners");let $="";for(let G=1;G<I[c].length;G++){G===1?$=I[c][E][0]:$=$+z+I[c][E][0];for(let V=1;V<I[c].length;V++)if(I[c][E][1]===I[c][V][2]){E=V;break}}I[c]=[I[c][0],$]}this.markedface=k,this.options.verbosity>1&&(console.log(`# Face names: ${N.map(c=>c[1]).join(" ")}`),console.log(`# Edge names: ${p.map(c=>c[1]).join(" ")}`),console.log(`# Vertex names: ${I.map(c=>c[1]).join(" ")}`));const O=[];for(const c of Y)O.push([c[0].makenormal(),c[1],"f"]);for(const c of p)O.push([c[0].makenormal(),c[1],"e"]);for(const c of I)O.push([c[0].makenormal(),c[1],"v"]);this.facenames=N,this.faceplanes=Y,this.edgenames=p,this.vertexnames=I,this.geonormals=O;const K=O.map(c=>c[1]);this.swizzler.setGripNames(K),this.options.verbosity>0&&console.log(`# Distances: face 1 edge ${this.edgedistance} vertex ${this.vertexdistance}`);for(let c=0;c<y.length;c++)for(const x of this.rotations){const j=y[c].rotateplane(x);let E=!1;for(const $ of this.moveplanes)if(j.sameplane($)){E=!0;break}E||(this.moveplanes.push(j),L[c]&&this.moveplanes2.push(j))}let A=new Me(f);const J=this.moveplanes2.slice();let _=31;for(let c=0;c<J.length;c++){const x=c+Math.floor((J.length-c)*(_/65536));A=A.split(J[x]),J[x]=J[c],_=(_*1657+101)%65536}const Q=A.collect([],!0);this.faces=Q,this.options.verbosity>0&&console.log(`# Faces is now ${Q.length}`),this.stickersperface=Q.length;const it=[],tt=yt(f);for(const c of this.rotations){const x=c.rotateface(f);tt.dist(yt(x))<W&&it.push(c)}const X=new Array(Q.length),Z=[];for(let c=0;c<Q.length;c++){const x=Q[c].centermass();Z.push([tt.dist(x),x,c])}Z.sort((c,x)=>c[0]-x[0]);for(let c=0;c<Q.length;c++){const x=Z[c][2];if(!X[x]){X[x]=!0;for(const j of it){const E=Q[x].rotate(j),$=E.centermass();for(let G=c+1;G<Q.length&&!(Z[G][0]-Z[c][0]>W);G++){const V=Z[G][2];if(!X[V]&&$.dist(Z[G][1])<W){X[V]=!0,Q[V]=E;break}}}}}this.shortedge=1e99;for(const c of Q)for(let x=0;x<c.length;x++){const j=(x+1)%c.length,E=c.get(x).dist(c.get(j));E<this.shortedge&&(this.shortedge=E)}this.options.verbosity>0&&console.log(`# Short edge is ${this.shortedge}`),t==="c"&&g&&!B&&!M&&(this.addNotationMapper="NxNxNCubeMapper",this.setReidOrSpeffzOrder=!0),t==="c"&&M&&!g&&!B&&(this.addNotationMapper="SkewbMapper"),t==="t"&&(M||g)&&!B&&(this.addNotationMapper="PyraminxOrTetraminxMapper"),t==="o"&&g&&(this.notationMapper=new Dt(this.swizzler,new pt(["F","D","L","BL","R","U","BR","B"])),B||M||(this.addNotationMapper="FTOMapper")),t==="d"&&g&&(this.addNotationMapper="MegaminxMapper",this.notationMapper=new Dt(this.swizzler,new pt(["U","F","L","BL","BR","R","FR","FL","DL","B","DR","D"])))}keyface(e){return this.keyface2(e.centermass())}keyface2(e){let t="";const s=String.fromCharCode;for(const i of this.moveplanesets)if(i.length>0){const n=e.dot(i[0]);let o=0,r=1;for(;r*2<=i.length;)r*=2;for(;r>0;r>>=1)o+r<=i.length&&n>i[o+r-1].a&&(o+=r);if(o<47)t=t+s(33+o);else if(o<47+47*47)t=t+s(80+Math.floor(o/47)-1)+s(33+o%47);else if(o<47+47*47+47*47*47)t=t+s(80+Math.floor((o-47)/(47*47)-1))+s(80+Math.floor((o-47)/47)%47)+s(33+o%47);else throw Error("Too many slices for cubie encoding")}return t}keyface3(e){const t=e.centermass(),s=[];for(const i of this.moveplanesets)if(i.length>0){const n=t.dot(i[0]);let o=0,r=1;for(;r*2<=i.length;)r*=2;for(;r>0;r>>=1)o+r<=i.length&&n>i[o+r-1].a&&(o+=r);s.push(o)}return s}findface(e){const t=this.keyface2(e),s=this.facelisthash.get(t);if(s.length===1)return s[0];for(let i=0;i+1<s.length;i++){const n=this.facelisthash.get(t)[i];if(Math.abs(e.dist(this.facecentermass[n]))<W)return n}return s[s.length-1]}project2d(e,t,s){const i=this.facenames[e][0],n=(t+1)%i.length,o=this.baseplanes[e];let r=i[n].sub(i[t]);const u=r.len();r=r.normalize();const l=r.cross(o).normalize();let h=s[1].sub(s[0]);const v=h.len()/u;h=h.normalize();const d=h.b,w=h.c,m=r.smul(d).sub(l.smul(w)).smul(v),a=l.smul(d).sum(r.smul(w)).smul(v),f=new H(0,s[0].b-m.dot(i[t]),s[0].c-a.dot(i[t]),0);return[m,a,f]}upperStringToBitSet(e){let t=0;for(let s=0;s<e.length;s++)t|=1<<e.charCodeAt(s)-65;return t}allstickers(){this.faces=De(this.baseplanerot,this.faces),this.options.verbosity>0&&console.log(`# Total stickers is now ${this.faces.length}`),this.facecentermass=new Array(this.faces.length);for(let p=0;p<this.faces.length;p++)this.facecentermass[p]=this.faces[p].centermass();const e=[],t=[];for(const p of this.moveplanes){const F=p.makenormal();let P=!1;for(const C of t)F.sameplane(C.makenormal())&&(P=!0);P||(t.push(F),e.push([]))}for(const p of this.moveplanes2){const F=p.makenormal();for(let P=0;P<t.length;P++)if(F.sameplane(t[P])){e[P].push(p);break}}for(let p=0;p<e.length;p++){const F=e[p].map(C=>C.normalizeplane()),P=t[p];for(let C=0;C<F.length;C++)F[C].makenormal().dist(P)>W&&(F[C]=F[C].smul(-1));F.sort((C,R)=>C.a-R.a),e[p]=F}this.moveplanesets=e,this.moveplanenormals=t;const s=e.map(p=>p.length);this.options.verbosity>0&&console.log(`# Move plane sets: ${s}`);const i=[];for(let p=0;p<e.length;p++)i.push([]);for(const p of this.rotations){if(Math.abs(Math.abs(p.a)-1)<W)continue;const F=p.makenormal();for(let P=0;P<e.length;P++)if(F.sameplane(t[P])){i[P].push(p);break}}this.moverotations=i;for(let p=0;p<i.length;p++){const F=i[p],P=F[0].makenormal();for(let C=0;C<F.length;C++)P.dist(F[C].makenormal())>W&&(F[C]=F[C].smul(-1));F.sort((C,R)=>C.angle()-R.angle()),i[p][0].dot(t[p])<0&&F.reverse()}const n=i.map(p=>1+p.length);this.movesetorders=n;const o=[];let r="?";for(let p=0;p<e.length;p++){const F=t[p];let P=null,C=null;for(const R of this.geonormals){const D=F.dot(R[0]);Math.abs(D-1)<W?(C=[R[1],R[2]],r=R[2]):Math.abs(D+1)<W&&(P=[R[1],R[2]],r=R[2])}if(C===null||P===null)throw Error("Saw positive or negative sides as null");o.push([C[0],C[1],P[0],P[1],1+e[p].length]),this.addNotationMapper==="NxNxNCubeMapper"&&r==="f"&&(this.notationMapper=new se(1+e[p].length),this.addNotationMapper=""),this.addNotationMapper==="SkewbMapper"&&e[0].length===1&&(this.notationMapper=new he(this.swizzler),this.addNotationMapper=""),this.addNotationMapper==="PyraminxOrTetraminxMapper"&&(e[0].length===2&&e[0][0].a===.333333333333333&&e[0][1].a===1.66666666666667?(this.notationMapper=new Tt(this.swizzler),this.addNotationMapper=""):(this.notationMapper=new oe(this.swizzler),this.addNotationMapper="")),this.addNotationMapper==="MegaminxMapper"&&r==="f"&&(1+e[p].length===3&&(this.notationMapper=new ee(this.notationMapper)),this.addNotationMapper=""),this.addNotationMapper==="FTOMapper"&&r==="f"&&(1+e[p].length===3&&(this.notationMapper=new te(this.notationMapper,this.swizzler)),this.addNotationMapper="")}this.movesetgeos=o;const u=new Map,l=this.faces;for(let p=0;p<l.length;p++){const F=l[p],P=this.keyface(F);if(!u.get(P))u.set(P,[p]);else{const C=u.get(P);if(C.push(p),C.length===this.baseFaceCount){this.options.verbosity>0&&console.log("# Splitting core.");for(let R=0;R<C.length;R++){const D=`${P} ${R}`;u.set(D,[C[R]])}}}}this.facelisthash=u,this.options.verbosity>0&&console.log(`# Cubies: ${u.size}`);const h=[],v=[],d=[];for(const p of u.values())if(p.length!==this.baseFaceCount){if(p.length>1){const F=p.map(z=>l[z].centermass()),P=yt(F);for(let z=0;p.length>2;z++){let T=!1;for(let k=0;k<p.length;k++){const O=(k+1)%p.length;if(P.dot(F[k].cross(F[O]))<0){const K=F[k];F[k]=F[O],F[O]=K;const A=p[k];p[k]=p[O],p[O]=A,T=!0}}if(!T)break;if(z>1e3)throw Error("Bad epsilon math; too close to border")}let C=0;for(const z of p)C|=1<<Math.floor(z/this.stickersperface);const R=this.markedface[C];let D=-1;for(let z=0;z<p.length;z++)Math.floor(p[z]/this.stickersperface)===R&&(D=z);if(D<0)throw Error("Could not find marked face in list");if(D!==0){const z=p.slice();for(let T=0;T<p.length;T++)p[T]=z[(D+T)%p.length]}}for(let F=0;F<p.length;F++){const P=p[F];v[P]=h.length,d[P]=F}h.push(p)}this.cubies=h,this.facetocubie=v,this.facetoord=d;const w=["?","CENTERS","EDGES","CORNERS","C4RNER","C5RNER"],m=[],a=[0,0,0,0,0,0],f=[],y=[];let L=0;const g=[],B=[],M=[],N=[],Y=p=>h[p].map(F=>this.getfaceindex(F)).join(" "),I=[];for(let p=0;p<h.length;p++){const F=h[p];if(F.length===0||y[p])continue;const P={};let C=0;M.push(0),I.push([]);const R=F.length,D=a[R]++;let z=w[R];(z===void 0||R===this.baseFaceCount)&&(z="CORE"),z=z+(D===0?"":D+1),m[L]=z,f[L]=R;const T=[p];let k=0;for(y[p]=!0;k<T.length;){const O=T[k++],K=Y(O);if((F.length>1||P[K]===void 0)&&(P[K]=C++),N[O]=P[K],g[O]=L,I[L].push(O),B[O]=M[L]++,T.length<this.rotations.length){const A=this.facecentermass[h[O][0]];for(const J of i){const _=this.facetocubie[this.findface(A.rotatepoint(J[0]))];y[_]||(T.push(_),y[_]=!0)}}}L++}if(this.setReidOrSpeffzOrder&&4<=this.stickersperface){const p=[["UF","UR","UB","UL","DF","DR","DB","DL","FR","FL","BR","BL"],["UFR","URB","UBL","ULF","DRF","DFL","DLB","DBR"],["U","L","F","R","B","D"]],F=["U","L","F","R","B","D"],P=["UBL","URB","UFR","ULF","UBL","ULF","DFL","DLB","ULF","UFR","DRF","DFL","UFR","URB","DBR","DRF","URB","UBL","DLB","DBR","DFL","DRF","DBR","DLB"],C={};for(const k of p)for(let O=0;O<k.length;O++)C[this.upperStringToBitSet(k[O])]=O;const R={},D={},z=[],T=[-1,0,1,0,2,-1,1,-1,3,3,-1,-1,2,-1,-1,-1];if(this.stickersperface>9){for(const k of this.vertexnames)R[this.upperStringToBitSet(k[1])]=k[0];for(let k=0;k<6;k++)D[F[k]]=k;for(const k of P)z.push(R[this.upperStringToBitSet(k)])}for(const k of I)for(const O of k)if(h[O].length===3||this.stickersperface<=9){let K=0;for(const A of h[O])K|=1<<this.facenames[this.getfaceindex(A)][1].charCodeAt(0)-65;B[O]=C[K]}else if(h[O].length<=2){const K=[];for(let A=0;A<h[O].length;A++){const J=h[O][A],_=D[this.facenames[this.getfaceindex(J)][1]];let Q=1e20;const it=this.faces[J].centermass();let tt=0;for(let X=0;X<4;X++){const Z=it.dist(z[4*_+X]);Z+W<Q?(Q=Z,tt=1<<X):Z<Q+W&&(tt|=1<<X)}if(tt=T[tt],tt>=0){const X=4*_+tt;K.push([X,P[X]])}}if(K.length>0){if(h[O].length===1)B[O]=K[0][0];else if(K.length===2&&K[0][1]===K[1][1]){let A=0;const J=F[K[0][0]>>2],_=F[K[1][0]>>2],Q=K[0][1];for(;A<3&&(J===Q.charAt(A)||_===Q.charAt(A));)A++;if(A===3)throw Error("Internal error (2) in Speffz");if(A=(A+1)%3,J===Q.charAt(A))B[O]=K[0][0];else if(_===Q.charAt(A))B[O]=K[1][0];else throw console.log(J,_,Q,A,K),Error("Internal error (3) in Speffz")}}}}if(this.cubiesetnums=g,this.cubieordnums=B,this.cubiesetnames=m,this.cubieords=M,this.orbitoris=f,this.cubievaluemap=N,this.cubiesetcubies=I,this.options.fixedPieceType!==null){for(let p=0;p<h.length;p++)if(this.options.fixedPieceType==="v"&&h[p].length>2||this.options.fixedPieceType==="e"&&h[p].length===2||this.options.fixedPieceType==="f"&&h[p].length===1){this.fixedCubie=p;break}if(this.fixedCubie<0)throw Error(`Could not find a cubie of type ${this.options.fixedPieceType} to fix.`)}this.options.verbosity>0&&console.log(`# Cubie orbit sizes ${M}`)}unswizzle(e){const t=this.notationMapper.notationToInternal(e);return t===null?null:t.modified({family:this.swizzler.unswizzle(t.family)})}stringToBlockMove(e){const t=/^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$/,s=e.match(t);if(s===null)throw Error(`Bad move passed ${e}`);const i=s[4];let n,o;if(s[2]!==void 0){if(s[3]===void 0)throw Error("Missing second number in range");n=parseInt(s[2],10)}s[3]!==void 0&&(o=parseInt(s[3],10));let r="1",u=1;return s[5]!==void 0&&(r=s[5],r[0]==="'"&&(r=`-${r.substring(1)}`),u=parseInt(r,10)),new U(new S(i,o,n),u)}parseMove(e){const t=this.notationMapper.notationToInternal(e);if(t===null)throw Error(`Bad move ${e.family}`);e=t;let s=e.family,i=!1;if(s.endsWith("v")&&s[0]<="Z"){if(e.innerLayer!==void 0||e.outerLayer!==void 0)throw Error("Cannot use a prefix with full cube rotations");s=s.slice(0,-1),i=!0}s.endsWith("w")&&s[0]<="Z"&&(s=s.slice(0,-1).toLowerCase());let n,o=-1;const r=this.swizzler.unswizzle(s);let u=!1;for(let v=0;v<this.movesetgeos.length;v++){const d=this.movesetgeos[v];r===d[0]&&(u=!0,n=d,o=v),r===d[2]&&(u=!1,n=d,o=v)}let l=1,h=1;if(s.toUpperCase()!==s&&(h=2),n===void 0)throw Error(`Bad grip in move ${e.family}`);if(e.outerLayer!==void 0&&(l=e.outerLayer),e.innerLayer!==void 0&&(e.outerLayer===void 0?(h=e.innerLayer,s<="Z"?l=h:l=1):h=e.innerLayer),l--,h--,i&&(l=0,h=this.moveplanesets[o].length),l<0||l>this.moveplanesets[o].length||h<0||h>this.moveplanesets[o].length)throw Error(`Bad slice spec ${l} ${h} vs ${this.moveplanesets[o].length}`);if(l===0&&h===this.moveplanesets[o].length&&!i)throw Error("! full puzzle rotations must be specified with v suffix.");return[void 0,o,l,h,u,e.amount]}parsemove(e){const t=this.parseMove(this.stringToBlockMove(e));return t[0]=e,t}genperms(){if(this.cmovesbyslice.length>0)return;const e=[];if(this.options.orientCenters){for(let t=0;t<this.cubies.length;t++)if(this.cubies[t].length===1){const s=this.cubies[t][0],i=this.getfaceindex(s),n=this.basefaces[i].centermass();if(n.dist(this.facecentermass[s])<W){const o=1<<i|1<<this.baseFaceCount,r=this.markedface[o],u=this.baseplanes[r].makenormal();let l=-1,h=-1;for(let w=0;w<this.faces[s].length;w++){const m=this.faces[s].get(w),a=u.dot(m.sub(n));a>l&&(l=a,h=w)}const v=(h+1)%this.faces[s].length;if(Math.abs(u.dot(this.faces[s].get(v).sub(n))-l)<W&&(h=v),h!==0){const w=[];for(let m=0;m<this.faces[s].length;m++)w.push(this.faces[s].get((m+h)%this.faces[s].length));this.faces[s]=new Bt(w)}const d=this.basefaces[i].length;for(let w=1;w<d;w++)this.cubies[t].push(this.cubies[t][w-1]);this.duplicatedFaces[s]=d,this.duplicatedCubies[t]=d,this.orbitoris[this.cubiesetnums[t]]=d}}}for(let t=0;t<this.moveplanesets.length;t++){const s=this.moveplanesets[t],i=[],n=[s.length+1,0];let o=1;for(;o*2<=s.length;)o*=2;for(let l=0;l<this.faces.length;l++){let h=0;if(s.length>0){const v=this.facecentermass[l].dot(s[0]);for(let d=o;d>0;d>>=1)h+d<=s.length&&v>s[h+d-1].a&&(h+=d);h=s.length-h}for(i.push(h);n.length<=h;)n.push(0);n[h]++}const r=new Array(n.length);for(let l=0;l<n.length;l++)r[l]=[];const u=[];for(let l=0;l<this.faces.length;l++){if(i[l]<0)continue;const h=[this.facetocubie[l],this.facetoord[l]];let v=this.facecentermass[l];const d=v;let w=l;const m=i[w];for(;;){i[w]=-1;const a=v.rotatepoint(this.moverotations[t][0]);if(a.dist(d)<W)break;w=this.findface(a),h.push(this.facetocubie[w],this.facetoord[w]),v=a}if(h.length>2&&this.options.orientCenters&&(this.cubies[h[0]].length===1||this.duplicatedCubies[h[0]]>1)&&this.facecentermass[l].dist(this.basefaces[this.getfaceindex(l)].centermass())<W){let a=this.faces[this.cubies[h[0]][0]];for(let f=0;f<h.length;f+=2){const y=this.faces[this.cubies[h[f]][0]];let L=-1;for(let g=0;g<a.length;g++)if(y.get(g).dist(a.get(0))<W){L=g;break}if(L<0)throw Error("Couldn't find rotation of center faces; ignoring for now.");h[f+1]=L,a=a.rotate(this.moverotations[t][0])}}if(h.length===2&&this.options.orientCenters){const a=this.facecentermass[l].dot(this.moveplanenormals[t]);for(let f=1;f<this.movesetorders[t];f++)a>0?h.push(h[0],f):h.push(h[0],(this.movesetorders[t]-f)%this.movesetorders[t])}if(h.length>2&&!u[h[0]]){if(h.length!==2*this.movesetorders[t])throw Error("Bad length in perm gen");for(const a of h)r[m].push(a)}for(let a=0;a<h.length;a+=2)u[h[a]]=!0}for(let l=0;l<r.length;l++)r[l]=r[l].slice();e.push(r)}if(this.cmovesbyslice=e,this.options.moveList){const t=[];for(const s of this.options.moveList)t.push(this.parsemove(s));this.parsedmovelist=t}this.facelisthash.clear(),this.facecentermass=[]}getboundarygeometry(){return{baseplanes:this.baseplanes,facenames:this.facenames,faceplanes:this.faceplanes,vertexnames:this.vertexnames,edgenames:this.edgenames,geonormals:this.geonormals}}getmovesets(e){const t=this.moveplanesets[e].length;let s=[];if(this.parsedmovelist!==void 0)for(const i of this.parsedmovelist)i[1]===e&&(i[4]?s.push([i[2],i[3]]):s.push([t-i[3],t-i[2]]),s.push(i[5]));else{const i=this.movesetgeos[e],n=i[1]!==i[3];if(this.options.vertexMoves&&n&&!this.options.allMoves){if(i[1]!==i[3])for(let o=0;o<t;o++)i[1]!=="v"?(this.options.outerBlockMoves?s.push([o+1,t]):s.push([o+1,o+1]),s.push(1)):(this.options.outerBlockMoves?s.push([0,o]):s.push([o,o]),s.push(1))}else for(let o=0;o<=t;o++)!this.options.allMoves&&o+o===t||(this.options.outerBlockMoves?o+o>t?s.push([o,t]):s.push([0,o]):s.push([o,o]),s.push(1))}if(this.fixedCubie>=0){const i=this.keyface3(this.faces[this.cubies[this.fixedCubie][0]])[e],n=[];for(let o=0;o<s.length;o+=2){let r=s[o];if(i>=r[0]&&i<=r[1])if(r[0]===0)r=[r[1]+1,t];else if(t===r[1])r=[0,r[0]-1];else throw Error("fixed cubie option would disconnect move");let u=!1;for(let l=0;l<n.length;l+=2)if(n[l][0]===r[0]&&n[l][1]===r[1]&&n[l+1]===s[o+1]){u=!0;break}u||(n.push(r),n.push(s[o+1]))}s=n}return s}graybyori(e){let t=this.cubies[e].length;return this.duplicatedCubies[e]&&(t=1),t===1&&(this.options.grayCenters||!this.options.includeCenterOrbits)||t===2&&(this.options.grayEdges||!this.options.includeEdgeOrbits)||t>2&&(this.options.grayCorners||!this.options.includeCornerOrbits)}skipbyori(e){let t=this.cubies[e].length;return this.duplicatedCubies[e]&&(t=1),t===1&&!this.options.includeCenterOrbits||t===2&&!this.options.includeEdgeOrbits||t>2&&!this.options.includeCornerOrbits}skipcubie(e){return this.skipbyori(e)}header(e){return`${e+ze}
${e}
`}writegap(){const e=this.getOrbitsDef(!1),t=[],s=[];for(let n=0;n<e.moveops.length;n++){let o=`M_${ut(this.notationMapper,e.movenames[n])}`,r=!1;o[o.length-1]==="'"&&(o=o.substring(0,o.length-1),r=!0),s.push(o),r?t.push(`${o}:=${e.moveops[n].toPerm().inv().toGap()};`):t.push(`${o}:=${e.moveops[n].toPerm().toGap()};`)}t.push("Gen:=["),t.push(s.join(",")),t.push("];");const i=e.solved.identicalPieces();return t.push(`ip:=[${i.map(n=>`[${n.map(o=>o+1).join(",")}]`).join(",")}];`),t.push("# Size(Group(Gen));"),t.push("# Size(Stabilizer(Group(Gen), ip, OnTuplesSets));"),t.push(""),this.header("# ")+t.join(`
`)}writemathematica(){const e=this.getOrbitsDef(!1),t=[],s=[];t.push(`(* ${this.header("").trim()} *)`);for(let i=0;i<e.moveops.length;i++){let n=`m${ut(this.notationMapper,e.movenames[i])}`,o=!1;n[n.length-1]==="'"&&(n=n.substring(0,n.length-1),o=!0),s.push(n),o?t.push(`${n}=${e.moveops[i].toPerm().inv().toMathematica()};`):t.push(`${n}=${e.moveops[i].toPerm().toMathematica()};`)}return t.push(`gen={${s.join(",")}};`),t.join(`
`)}writeksolve(e="PuzzleGeometryPuzzle"){const t=this.getOrbitsDef(!1);return this.header("# ")+t.toKsolve(e,this.notationMapper).join(`
`)}getKPuzzleDefinition(e=!0,t=!0){const i=this.getOrbitsDef(e,t).toKPuzzleDefinition(t);if(i.experimentalPuzzleDescription=this.puzzleDescription,!i)throw Error("Missing definition!");return i}getMoveFromBits(e,t,s,i,n,o){const r=[],u=[],l=[];for(const d of this.cubieords)u.push(st(d)),l.push(ot(d));for(let d=e[0];d<=e[1];d++){const w=i[d];for(let m=0;m<w.length;m+=2*o){const a=w.slice(m,m+2*o),f=this.cubiesetnums[a[0]];for(let g=0;g<a.length;g+=2)a[g]=this.cubieordnums[a[g]];let y=2,L=3;s&&(y=a.length-2,L=a.length-1),u[f]===st(this.cubieords[f])&&(u[f]=u[f].slice(),this.orbitoris[f]>1&&!this.options.fixedOrientation&&(l[f]=l[f].slice()));for(let g=0;g<a.length;g+=2)u[f][a[(g+y)%a.length]]=a[g],this.orbitoris[f]>1&&!this.options.fixedOrientation&&(l[f][a[g]]=(a[(g+L)%a.length]-a[(g+1)%a.length]+2*this.orbitoris[f])%this.orbitoris[f])}}let h=new rt(st(24),ot(24),1);for(let d=0;d<this.cubiesetnames.length;d++)if(!(n&&!n[d]))if(this.orbitoris[d]===1||this.options.fixedOrientation)u[d]===st(h.perm.length)?(u[d]!==h.perm&&(h=new rt(u[d],l[d],1)),r.push(h)):r.push(new rt(u[d],l[d],1));else{const w=new Array(l[d].length);for(let m=0;m<u[d].length;m++)w[m]=l[d][u[d][m]];r.push(new rt(u[d],w,this.orbitoris[d]))}let v=new Qt(r);return t!==1&&(v=v.mulScalar(t)),v}omitSet(e){for(const t of this.options.excludeOrbits)if(t===e)return!0;return!1}diffmvsets(e,t,s,i){for(let n=0;n<e.length;n+=2){let o=!1;for(let r=0;!o&&r<t.length;r+=2)i?e[n][0]+t[r][1]===s&&e[n][1]+t[r][0]===s&&e[n+1]===t[r+1]&&(o=!0):e[n][0]===t[r][0]&&e[n][1]===t[r][1]&&e[n+1]===t[r+1]&&(o=!0);if(!o)return!0}return!1}getOrbitsDef(e,t=!0){const s=[];if(e)for(let a=0;a<this.cubiesetnames.length;a++)s.push(1);const i=[],n=[],o=[],r=[];for(let a=0;a<this.moveplanesets.length;a++){const f=this.getmovesets(a);o.push(f),this.options.addRotations?r.push(1):r.push(0)}const u=[];for(let a=0;a<this.moveplanesets.length;a++){const f=this.moveplanesets[a].length;let y=!1;const L=o[a];for(let g=0;g<L.length;g+=2)L[g][0]===0&&L[g][1]===f&&(y=!0);u[a]=y}if(this.options.addRotations&&(this.options.moveList||this.options.fixedPieceType!==null)){for(let a=0;a<this.moverotations.length;a++)r[a]=0;for(let a=0;a<this.moveplanesets.length;a++){if(u[a]){r[a]=3;continue}for(let f=0;f<this.moverotations.length;f++){let y=this.moveplanenormals[a];for(let L=1;L*2<=this.movesetorders[f];L++){if(y=y.rotatepoint(this.moverotations[f][0]),r[f]&L)continue;let g=-1,B=!1;for(let N=0;N<this.moveplanenormals.length;N++)if(y.dist(this.moveplanenormals[N])<W){g=N;break}else if(y.dist(this.moveplanenormals[N].smul(-1))<W){g=N,B=!0;break}if(g<0)throw Error("Could not find rotation");const M=o[g];(M.length!==o[a].length||this.moveplanesets[a].length!==this.moveplanesets[g].length||this.diffmvsets(M,o[a],this.moveplanesets[g].length,B))&&(r[f]|=L)}}}for(let a=0;a<this.moverotations.length;a++)if(r[a]===0)r[a]=1;else if(r[a]===1)this.movesetorders[a]>3?r[a]=2:r[a]=0;else if(r[a]===3)r[a]=0;else throw Error("Impossible addrot val")}for(let a=0;a<this.moveplanesets.length;a++)r[a]!==0&&!u[a]&&(o[a].push([0,this.moveplanesets[a].length]),o[a].push(r[a]));for(let a=0;a<this.moveplanesets.length;a++){const f=o[a],y=this.movesetorders[a];for(let B=0;B<f.length;B+=2)for(let M=0;M<B;M+=2)if(f[B][0]===f[M][0]&&f[B][1]===f[M][1])throw Error("Redundant moves in moveset.");const L=[];for(let B=0;B<f.length;B+=2)for(let M=f[B][0];M<=f[B][1];M++)L[M]=1;const g=this.cmovesbyslice[a];for(let B=0;B<g.length;B++){if(L[B]!==1)continue;const M=g[B];for(let N=0;N<M.length;N+=2*y){if(this.skipcubie(M[N]))continue;const Y=this.cubiesetnums[M[N]];s[Y]=1}}}for(let a=0;a<this.cubiesetnames.length;a++)if(s[a]){if(this.omitSet(this.cubiesetnames[a])){s[a]=0;continue}i.push(this.cubiesetnames[a]),n.push(new Lt(this.cubieords[a],this.options.fixedOrientation?1:this.orbitoris[a]))}const l=[];for(let a=0;a<this.cubiesetnames.length;a++){if(!s[a]||this.omitSet(this.cubiesetnames[a]))continue;const f=[],y=[];for(let L=0;L<this.cubieords[a];L++){if(e)f.push(L);else{const g=this.cubiesetcubies[a][L];f.push(this.cubievaluemap[g])}y.push(0)}l.push(new rt(f,y,this.options.fixedOrientation?1:this.orbitoris[a]))}const h=[],v=[],d=[],w=[];if(t)for(let a=0;a<this.moveplanesets.length;a++){const y=this.moveplanesets[a].length,L=o[a],g=this.movesetgeos[a];for(let B=0;B<L.length;B+=2){const M=L[B];let N,Y=!1;if(this.parsedmovelist!==void 0)for(const p of this.parsedmovelist){if(p[1]!==a)continue;let F=[];p[4]?F=[p[2],p[3]]:F=[y-p[3],y-p[2]],F[0]===M[0]&&F[1]===M[1]&&(N=p[0],Y=!p[4])}if(N)h.push(N),v.push(!0);else{const p=Ce(g,M,y);Y=p[1];const F=p[0];L[B+1]===1?h.push(F):h.push(F+L[B+1]),v.push(!1)}w.push(M[0]===0&&M[1]===y);const I=this.getMoveFromBits(M,L[B+1],Y,this.cmovesbyslice[a],s,this.movesetorders[a]);d.push(I)}}let m=new At(i,n,new Ht(l),h,d,w,v);return this.options.optimizeOrbits&&(m=m.optimize()),this.options.scrambleAmount!==0&&m.scramble(this.options.scrambleAmount),m}getScramble(e=0){const t=this.getOrbitsDef(!1);return t.toKTransformationData(t.getScrambleTransformation(e))}getMovesAsPerms(){return this.getOrbitsDef(!1).moveops.map(e=>e.toPerm())}showcanon(e){ge(this.getOrbitsDef(!1),e)}getsolved(){const e=[];for(let t=0;t<this.baseFaceCount;t++)for(let s=0;s<this.stickersperface;s++)e.push(t);return new at(e)}getOrientationRotation(e){const[t,[s,i,n]]=e[0],o=new H(0,s,-i,n),[r,[u,l,h]]=e[1],v=new H(0,u,-l,h);let d=null,w=null;const m=this.swizzler.unswizzle(t),a=this.swizzler.unswizzle(r);for(const g of this.geonormals)m===g[1]&&(d=g[0]),a===g[1]&&(w=g[0]);if(!d)throw Error(`Could not find feature ${t}`);if(!w)throw Error(`Could not find feature ${r}`);const f=d.pointrotation(o);return w.rotatepoint(f).unproject(o).pointrotation(v.unproject(o)).mul(f)}getInitial3DRotation(){const e=this.baseFaceCount;let t=null;if(this.options.puzzleOrientation?t=this.options.puzzleOrientation:this.options.puzzleOrientations&&(t=this.options.puzzleOrientations[e]),t||(t=Ue()[e]),!t)throw Error("No default orientation?");return this.getOrientationRotation(t)}generate2dmapping(e=800,t=500,s=10,i=!1,n=.92){e-=2*s,t-=2*s;function o(R,D){let z=R[1][0]-R[0][0],T=R[1][1]-R[0][1];const k=2*Math.PI/D,O=Math.cos(k),K=Math.sin(k);for(let A=2;A<D;A++){const J=z*O+T*K;T=T*O-z*K,z=J,R.push([R[A-1][0]+z,R[A-1][1]+T])}}this.genperms();const l=this.getboundarygeometry().facenames[0][0].length,h=this.net;if(h===null)throw Error("No net?");const v={};let d=0,w=0,m=1,a=0;v[h[0][0]]=[[1,0],[0,0]],o(v[h[0][0]],l);for(const R of h){const D=R[0];if(!v[D])throw Error("Bad edge description; first edge not connected.");for(let z=1;z<R.length;z++){const T=R[z];T===""||v[T]||(v[T]=[v[D][z%l],v[D][(z+l-1)%l]],o(v[T],l))}}for(const R in v){const D=v[R];for(const z of D)d=Math.min(d,z[0]),m=Math.max(m,z[0]),w=Math.min(w,z[1]),a=Math.max(a,z[1])}const f=Math.min(e/(m-d),t/(a-w)),y=.5*(e-f*(m+d)),L=.5*(t-f*(a+w)),g={},B=this.getboundarygeometry(),M={},N=[[f+y,L],[y,L]];M[h[0][0]]=N,o(M[h[0][0]],l),g[this.facenames[0][1]]=this.project2d(0,0,[new H(0,N[0][0],N[0][1],0),new H(0,N[1][0],N[1][1],0)]);const Y=[];Y[0]=0;for(const R of h){const D=R[0];if(!M[D])throw Error("Bad edge description; first edge not connected.");let z=-1;for(let k=0;k<B.facenames.length;k++)if(D===B.facenames[k][1]){z=k;break}if(z<0)throw Error(`Could not find first face name ${D}`);const T=B.facenames[z][0];for(let k=1;k<R.length;k++){const O=R[k];if(O===""||M[O])continue;M[O]=[M[D][k%l],M[D][(k+l-1)%l]],o(M[O],l);const K=Y[z],A=T[(K+k)%l].sum(T[(K+k+l-1)%l]).smul(.5),J=lt(B.edgenames,A),_=B.edgenames[J][1],Q=Pe(_,this.facenames),it=Q[D===Q[0]?1:0];let tt=-1;for(let Z=0;Z<B.facenames.length;Z++)if(it===B.facenames[Z][1]){tt=Z;break}if(tt<0)throw Error("Could not find second face name");const X=B.facenames[tt][0];for(let Z=0;Z<X.length;Z++)if(X[Z].sum(X[(Z+1)%l]).smul(.5).dist(A)<=W){const x=M[D][(k+l-1)%l],j=M[D][k%l];Y[tt]=Z,g[it]=this.project2d(tt,Z,[new H(0,j[0],j[1],0),new H(0,x[0],x[1],0)]);break}}}let I=0,p=0;const F=this.getInitial3DRotation();for(let R of this.faces){i&&(R=R.rotate(F));for(let D=0;D<R.length;D++)I=Math.max(I,Math.abs(R.get(D).b)),p=Math.max(p,Math.abs(R.get(D).c))}const P=Math.min(t/p/2,(e-s)/I/4);return(R,D)=>{if(i){D=D.rotatepoint(F);const z=.5*s+.25*e,T=this.baseplanes[R].rotateplane(F).d<0?1:-1;return[s+e*.5+T*(z-D.b*P),s+t*.5+D.c*P]}else{const z=g[this.facenames[R][1]];return[s+n*D.dot(z[0])+z[2].b,s+t-n*D.dot(z[1])-z[2].c]}}}generatesvg(e=800,t=500,s=10,i=!1){const n=this.generate2dmapping(e,t,s,i);function o(d,w,m){return`<polygon id="${d}" class="sticker" style="fill: ${m}" points="${w.map(a=>`${a[0]} ${a[1]}`).join(" ")}"/>
`}const r=this.getsolved(),u=[],l=[];for(let d=0;d<this.baseFaceCount;d++)u[d]=this.colors[this.facenames[d][1]];for(let d=0;d<this.faces.length;d++){const w=this.faces[d],m=Math.floor(d/this.stickersperface),a=[];for(let f=0;f<w.length;f++)a.push(n(m,w.get(f)));l.push(a)}const h=[];for(let d=0;d<this.baseFaceCount;d++){h.push("<g>"),h.push(`<title>${this.facenames[d][1]}</title>
`);for(let w=0;w<this.stickersperface;w++){const m=d*this.stickersperface+w,a=this.facetocubie[m],f=this.facetoord[m],y=this.cubiesetnums[a],L=this.cubieordnums[a],g=this.graybyori(a)?"#808080":u[r.p[m]];let B=`${this.cubiesetnames[y]}-l${L}-o${f}`;if(h.push(o(B,l[m],g)),this.duplicatedFaces[m])for(let M=1;M<this.duplicatedFaces[m];M++)B=`${this.cubiesetnames[y]}-l${L}-o${M}`,h.push(o(B,l[m],g))}h.push("</g>")}return`<svg id="svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 800 500">
<style type="text/css"><![CDATA[.sticker { stroke: #000000; stroke-width: 1px; }]]></style>
${h.join("")}</svg>`}get3d(e){const t=[],s=this.getInitial3DRotation(),i=[],n=.52*this.basefaces[0].get(0).len();for(let l=0;l<this.basefaces.length;l++){const h=this.basefaces[l].rotate(s),v=this.facenames[l][1];i.push({coords:xt(h,n),name:v})}for(let l=0;l<this.faces.length;l++){const h=Math.floor(l/this.stickersperface),v=this.facetocubie[l],d=this.facetoord[l],w=this.cubiesetnums[v],m=this.cubieordnums[v];let a=this.graybyori(v)?e!=null&&e.darkIgnoredOrbits?"#222222":"#808080":this.colors[this.facenames[h][1]];e!=null&&e.stickerColors&&(a=e.stickerColors[l]);const f=this.faces[l].rotate(s);t.push({coords:xt(f,n),color:a,orbit:this.cubiesetnames[w],ord:m,ori:d,face:h});let y=f;if(this.duplicatedFaces[l]){const L=y.length/this.duplicatedFaces[l];for(let g=1;g<this.duplicatedFaces[l];g++){for(let B=0;B<L;B++)y=y.rotateforward();t.push({coords:xt(y,n),color:a,orbit:this.cubiesetnames[w],ord:m,ori:g,face:h,isDup:!0})}}}const o=[];for(let l=0;l<this.movesetgeos.length;l++){const h=this.movesetgeos[l],v=this.movesetorders[l];for(const d of this.geonormals)h[0]===d[1]&&h[1]===d[2]&&(o.push({coordinates:ft(d[0].rotatepoint(s),1),quantumMove:new U(h[0]),order:v}),o.push({coordinates:ft(d[0].rotatepoint(s).smul(-1),1),quantumMove:new U(h[2]),order:v}))}const r=this.generate2dmapping(2880,2160,0,!1,1),u=(()=>{const l=s.invrot();return(h,v)=>{let d=new H(0,v[0]*n,-v[1]*n,v[2]*n);d=d.rotatepoint(l);const w=r(h,d);return w[0]/=2880,w[1]=1-w[1]/2160,w}})().bind(this);return{stickers:t,faces:i,axis:o,unswizzle:this.unswizzle.bind(this),notationMapper:this.notationMapper,textureMapper:{getuv:u}}}getGeoNormal(e){const t=this.getInitial3DRotation(),s=this.swizzler.unswizzle(e);for(const i of this.geonormals)if(s===i[1]){const n=ft(i[0].rotatepoint(t),1);return Math.abs(n[0])<W&&Math.abs(n[2])<W&&(n[0]=0,n[2]=1e-6),n}}getfaceindex(e){const t=this.stickersperface;return Math.floor(e/t)}textForTwizzleExplorer(){return`Faces ${this.baseplanerot.length}
Stickers per face ${this.stickersperface}
Short edge ${this.shortedge}
Cubies ${this.cubies.length}
Edge distance ${this.edgedistance}
Vertex distance ${this.vertexdistance}`}writeSchreierSims(e){const s=this.getOrbitsDef(!1).reassemblySize();e(`Reassembly size is ${s}`);const i=Re(this.getMovesAsPerms(),e),n=s/i;e(`Ratio is ${n}`)}},Qe=class{constructor(e,t){b(this,"orbitNames");this.pg=e,this.orbitNames=t.orbitnames}lookupMove(e){const t=this.pg.parseMove(e);if(this.pg.parsedmovelist){let o=!1;for(const r of this.pg.parsedmovelist)r[1]===t[1]&&r[2]===t[2]&&r[3]===t[3]&&r[4]===t[4]&&(o=!0);if(!o)return null}let s=[t[2],t[3]];if(!t[4]){const o=this.pg.moveplanesets[t[1]].length;s=[o-t[3],o-t[2]]}const i=this.pg.getMoveFromBits(s,t[5],!t[4],this.pg.cmovesbyslice[t[1]],void 0,this.pg.movesetorders[t[1]]);return At.transformToKTransformationData(this.orbitNames,i)}remapKPuzzleDefinition(e){return ce(e,this.pg.notationMapper)}};export{Ae as EXPERIMENTAL_PUZZLE_BASE_SHAPES,Ge as EXPERIMENTAL_PUZZLE_CUT_TYPES,Qe as ExperimentalPGNotation,Oe as PuzzleGeometry,H as Quat,Te as getPG3DNamedPuzzles,Ne as getPuzzleDescriptionString,je as getPuzzleGeometryByDesc,Ke as getPuzzleGeometryByName,Ie as parseOptions,Wt as parsePuzzleDescription,Re as schreierSims};
